
# merge

1. 这里会有很多的事务与非事务，merge 之后 transations 还存在吗，或者说具体形式什么样的

>1. merge 之后所有数据都是最新的，所以事务没必要存在了（nonTrasactionNum）

2. 如何 merge 的
>读文件里的 LogRecord 和 索引里面的 LogRecordPos 对比，看是否匹配，索引里面的数据是最新的，如果匹配上，就直接写到 merge 目录里

3. 文件结构，merge完成之后将 hint-index 还有 merge-finished 移动到原目录

```
- bitcask-go-merge
    - *.data
    - hint-index
    - merge-finished
```

# 索引

## 优化

索引始终存储在内存里面，存储引擎能够维护多少索引（key+索引）取决于内存容量

下面是两种解决办法

1. 使用一个更加节省存储空间的数据结构维护内存索引
2. 将索引存储在磁盘上，但性能会降低

### 存储空间优化

前者这里使用了 boltdb 库，其实现了标准的 B+ Tree

### 对 WriteBatch 的影响

将索引存储在磁盘上，不像以前那样每次都读取所有文件加载索引，就拿不到最新的事务序列号

1. 还是加载数据文件，但是可以从后往前，获取最新事务序列号
2. 在 B+ 树索引模式下，禁用 WriteBatch 的功能
3. 数据库 Close 时，将最新的事务序列号记录到一个文件中，启动时直接从这个文件获取。

### 索引锁粒度

使用多个索引树来存储索引，这里比较类似 leveldb 使用 ShardedLRUCache 的操作。

但是这时候顺序查找时不能像之前那样使用迭代器了，一个解决方法是使用一个东西维护这若个索引树的叶子节点的迭代器，每次只有具有最小元素的那个迭代器向前移动。


# IO

基于设计上的简洁性的考虑，这里实现只考虑单线程实例的存储引擎，对于多线程同时访问，同一时间应该只能有一个线程访问持有这个数据目录。

基于这种考虑，这里使用了文件锁 flock 来实现多线程互斥访问，一个数据目录只能一个 db 实例访问。
